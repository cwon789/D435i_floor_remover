#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <sensor_msgs/msg/imu.hpp>
#include <visualization_msgs/msg/marker.hpp>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <Eigen/Dense>
#include <deque>
#include <cfloat>

class FloorRemoverNode : public rclcpp::Node
{
public:
  FloorRemoverNode() : Node("floor_remover_node")
  {
    // Declare parameters
    this->declare_parameter("input_cloud_topic", "/camera/depth/color/points");
    this->declare_parameter("input_imu_topic", "/camera/imu");
    this->declare_parameter("output_cloud_topic", "/floor_removed_cloud");
    this->declare_parameter("floor_cloud_topic", "/floor_cloud");
    this->declare_parameter("gravity_marker_topic", "/gravity_vector");
    this->declare_parameter("voxel_leaf_size", 0.01);
    this->declare_parameter("plane_distance_threshold", 0.02);
    this->declare_parameter("plane_max_iterations", 100);
    this->declare_parameter("imu_buffer_size", 50);
    this->declare_parameter("use_imu_for_validation", true);
    this->declare_parameter("max_height_threshold", 2.0);
    this->declare_parameter("floor_normal_alignment_threshold", 0.7);
    this->declare_parameter("plane_smoothing_alpha", 0.3);
    this->declare_parameter("min_distance", 0.3);
    this->declare_parameter("max_distance", 5.0);

    // Get parameters
    input_cloud_topic_ = this->get_parameter("input_cloud_topic").as_string();
    input_imu_topic_ = this->get_parameter("input_imu_topic").as_string();
    output_cloud_topic_ = this->get_parameter("output_cloud_topic").as_string();
    floor_cloud_topic_ = this->get_parameter("floor_cloud_topic").as_string();
    gravity_marker_topic_ = this->get_parameter("gravity_marker_topic").as_string();
    voxel_leaf_size_ = this->get_parameter("voxel_leaf_size").as_double();
    plane_distance_threshold_ = this->get_parameter("plane_distance_threshold").as_double();
    plane_max_iterations_ = this->get_parameter("plane_max_iterations").as_int();
    imu_buffer_size_ = this->get_parameter("imu_buffer_size").as_int();
    use_imu_for_validation_ = this->get_parameter("use_imu_for_validation").as_bool();
    max_height_threshold_ = this->get_parameter("max_height_threshold").as_double();
    floor_normal_alignment_threshold_ = this->get_parameter("floor_normal_alignment_threshold").as_double();
    plane_smoothing_alpha_ = this->get_parameter("plane_smoothing_alpha").as_double();
    min_distance_ = this->get_parameter("min_distance").as_double();
    max_distance_ = this->get_parameter("max_distance").as_double();

    // Subscribers
    cloud_sub_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
      input_cloud_topic_, 10,
      std::bind(&FloorRemoverNode::cloudCallback, this, std::placeholders::_1));

    imu_sub_ = this->create_subscription<sensor_msgs::msg::Imu>(
      input_imu_topic_, 10,
      std::bind(&FloorRemoverNode::imuCallback, this, std::placeholders::_1));

    // Publishers
    cloud_pub_ = this->create_publisher<sensor_msgs::msg::PointCloud2>(output_cloud_topic_, 10);
    floor_pub_ = this->create_publisher<sensor_msgs::msg::PointCloud2>(floor_cloud_topic_, 10);
    gravity_marker_pub_ = this->create_publisher<visualization_msgs::msg::Marker>(gravity_marker_topic_, 10);

    // Initialize gravity vector (default pointing down in camera frame)
    gravity_vector_ = Eigen::Vector3d(0.0, 1.0, 0.0);

    // Initialize plane tracking
    has_previous_plane_ = false;
    previous_plane_coeffs_ = Eigen::Vector4d::Zero();

    RCLCPP_INFO(this->get_logger(), "Floor Remover Node initialized");
    RCLCPP_INFO(this->get_logger(), "Input cloud topic: %s", input_cloud_topic_.c_str());
    RCLCPP_INFO(this->get_logger(), "Input IMU topic: %s", input_imu_topic_.c_str());
    RCLCPP_INFO(this->get_logger(), "Use IMU for validation: %s", use_imu_for_validation_ ? "true" : "false");
  }

private:
  void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg)
  {
    // Add IMU data to buffer
    imu_buffer_.push_back(msg);

    // Keep buffer size limited
    if (imu_buffer_.size() > static_cast<size_t>(imu_buffer_size_)) {
      imu_buffer_.pop_front();
    }

    // Update gravity vector estimate from IMU
    updateGravityVector();
  }

  void updateGravityVector()
  {
    if (imu_buffer_.empty()) return;

    // Average acceleration over buffer to estimate gravity direction
    Eigen::Vector3d acc_sum(0.0, 0.0, 0.0);
    double variance_sum = 0.0;

    for (const auto& imu_msg : imu_buffer_) {
      acc_sum.x() += imu_msg->linear_acceleration.x;
      acc_sum.y() += imu_msg->linear_acceleration.y;
      acc_sum.z() += imu_msg->linear_acceleration.z;
    }
    acc_sum /= static_cast<double>(imu_buffer_.size());

    // Calculate variance to detect motion/vibration
    for (const auto& imu_msg : imu_buffer_) {
      Eigen::Vector3d diff(
        imu_msg->linear_acceleration.x - acc_sum.x(),
        imu_msg->linear_acceleration.y - acc_sum.y(),
        imu_msg->linear_acceleration.z - acc_sum.z()
      );
      variance_sum += diff.squaredNorm();
    }
    double variance = variance_sum / static_cast<double>(imu_buffer_.size());

    // Log IMU statistics periodically
    static int imu_log_count = 0;
    if (imu_log_count++ % 100 == 0) {
      RCLCPP_INFO(this->get_logger(),
                  "IMU: avg_acc=[%.2f, %.2f, %.2f] (mag=%.2f), variance=%.4f",
                  acc_sum.x(), acc_sum.y(), acc_sum.z(), acc_sum.norm(), variance);
    }

    // IMU measures acceleration opposite to gravity when stationary
    if (acc_sum.norm() > 0.1) {
      Eigen::Vector3d new_gravity = -acc_sum.normalized();

      // Apply low-pass filter to smooth gravity estimate
      // alpha = 0.1 means 10% new, 90% old (very smooth)
      double alpha = 0.1;
      Eigen::Vector3d filtered_gravity = alpha * new_gravity + (1.0 - alpha) * gravity_vector_;
      filtered_gravity.normalize();

      // Log if gravity changed significantly
      if ((filtered_gravity - gravity_vector_).norm() > 0.05) {
        RCLCPP_INFO(this->get_logger(),
                    "Gravity vector updated: [%.3f, %.3f, %.3f] -> [%.3f, %.3f, %.3f] (change: %.3f)",
                    gravity_vector_.x(), gravity_vector_.y(), gravity_vector_.z(),
                    filtered_gravity.x(), filtered_gravity.y(), filtered_gravity.z(),
                    (filtered_gravity - gravity_vector_).norm());
      }

      gravity_vector_ = filtered_gravity;
    }
  }

  void cloudCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)
  {
    // Convert ROS message to PCL point cloud
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
    pcl::fromROSMsg(*msg, *cloud);

    if (cloud->points.empty()) {
      RCLCPP_WARN(this->get_logger(), "Received empty point cloud");
      return;
    }

    // Step 1: Voxel grid downsampling
    // First, check for invalid points (NaN, Inf, or extremely large values)
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_clean(new pcl::PointCloud<pcl::PointXYZRGB>);
    float min_x = FLT_MAX, min_y = FLT_MAX, min_z = FLT_MAX;
    float max_x = -FLT_MAX, max_y = -FLT_MAX, max_z = -FLT_MAX;

    for (const auto& point : cloud->points) {
      // Skip invalid points
      if (!std::isfinite(point.x) || !std::isfinite(point.y) || !std::isfinite(point.z)) {
        continue;
      }

      // Distance filtering: only keep points within min/max distance range
      float distance = std::sqrt(point.x * point.x + point.y * point.y + point.z * point.z);
      if (distance < min_distance_ || distance > max_distance_) {
        continue;
      }

      cloud_clean->points.push_back(point);

      // Track bounding box
      min_x = std::min(min_x, point.x);
      min_y = std::min(min_y, point.y);
      min_z = std::min(min_z, point.z);
      max_x = std::max(max_x, point.x);
      max_y = std::max(max_y, point.y);
      max_z = std::max(max_z, point.z);
    }

    cloud_clean->width = cloud_clean->points.size();
    cloud_clean->height = 1;
    cloud_clean->is_dense = false;

    // Log point cloud statistics
    static int frame_count = 0;
    if (frame_count++ % 30 == 0) {  // Log every 30 frames
      float range_x = max_x - min_x;
      float range_y = max_y - min_y;
      float range_z = max_z - min_z;
      size_t filtered_count = cloud->points.size() - cloud_clean->points.size();
      RCLCPP_INFO(this->get_logger(),
                  "Cloud: %zu points -> %zu valid (filtered %zu, distance range: %.1f-%.1fm)",
                  cloud->points.size(), cloud_clean->points.size(), filtered_count,
                  min_distance_, max_distance_);
      RCLCPP_INFO(this->get_logger(),
                  "Bounds: X[%.2f,%.2f]=%.2fm, Y[%.2f,%.2f]=%.2fm, Z[%.2f,%.2f]=%.2fm",
                  min_x, max_x, range_x, min_y, max_y, range_y, min_z, max_z, range_z);
      RCLCPP_INFO(this->get_logger(),
                  "Voxel: leaf=%.3fm, estimated grid: X=%.0f, Y=%.0f, Z=%.0f",
                  voxel_leaf_size_, range_x/voxel_leaf_size_, range_y/voxel_leaf_size_, range_z/voxel_leaf_size_);
    }

    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZRGB>);
    pcl::VoxelGrid<pcl::PointXYZRGB> voxel_filter;
    voxel_filter.setInputCloud(cloud_clean);
    voxel_filter.setLeafSize(voxel_leaf_size_, voxel_leaf_size_, voxel_leaf_size_);
    voxel_filter.filter(*cloud_filtered);

    // Step 2: RANSAC plane segmentation on voxelized cloud
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_no_floor(new pcl::PointCloud<pcl::PointXYZRGB>);
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_floor_only(new pcl::PointCloud<pcl::PointXYZRGB>);

    // Find floor plane using RANSAC
    Eigen::Vector4d plane_coeffs;
    bool plane_found = findFloorPlane(cloud_filtered, plane_coeffs);

    // Use current plane if found, otherwise fall back to previous plane
    Eigen::Vector4d plane_to_use;
    bool use_plane = false;

    if (plane_found) {
      // Use plane directly without smoothing
      plane_to_use = plane_coeffs;
      previous_plane_coeffs_ = plane_coeffs;
      has_previous_plane_ = true;
      use_plane = true;

      RCLCPP_INFO(this->get_logger(), "✓ Floor plane [%.3f, %.3f, %.3f, %.3f]",
                  plane_coeffs[0], plane_coeffs[1], plane_coeffs[2], plane_coeffs[3]);
    } else if (has_previous_plane_) {
      // No new plane found, but we have a previous valid plane - reuse it
      plane_to_use = previous_plane_coeffs_;
      use_plane = true;
      RCLCPP_INFO(this->get_logger(), "↻ Reusing previous floor plane [%.3f, %.3f, %.3f, %.3f]",
                  previous_plane_coeffs_[0], previous_plane_coeffs_[1],
                  previous_plane_coeffs_[2], previous_plane_coeffs_[3]);
    } else {
      // No plane found and no previous plane available
      RCLCPP_WARN(this->get_logger(), "✗ No floor plane available");
      use_plane = false;
    }

    if (use_plane) {
      // Remove floor from voxelized cloud
      removeFloorPlane(cloud_filtered, plane_to_use, cloud_no_floor, cloud_floor_only);

      // Publish voxelized outputs only
      publishCloud(cloud_pub_, cloud_no_floor, msg->header);
      publishCloud(floor_pub_, cloud_floor_only, msg->header);
    } else {
      // No valid floor plane available at all - publish empty outputs
      publishCloud(cloud_pub_, cloud_filtered, msg->header);
      publishCloud(floor_pub_, pcl::PointCloud<pcl::PointXYZRGB>::Ptr(new pcl::PointCloud<pcl::PointXYZRGB>), msg->header);
    }

    // Publish gravity vector visualization
    publishGravityMarker(msg->header);
  }

  bool findFloorPlane(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
                      Eigen::Vector4d& plane_coeffs)
  {
    // RANSAC segmentation
    pcl::SACSegmentation<pcl::PointXYZRGB> seg;
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);

    seg.setOptimizeCoefficients(true);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(plane_max_iterations_);
    seg.setDistanceThreshold(plane_distance_threshold_);

    // Use PERPENDICULAR_PLANE model to find plane perpendicular to gravity
    // This makes RANSAC directly search for floor plane (not just largest plane)
    if (use_imu_for_validation_ && !imu_buffer_.empty()) {
      // IMU gravity vector를 이용해서 바닥 평면을 찾음
      // Floor normal = -gravity (위쪽 방향)
      Eigen::Vector3d floor_axis = -gravity_vector_;

      seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
      seg.setAxis(Eigen::Vector3f(floor_axis.x(), floor_axis.y(), floor_axis.z()));

      // Epsilon: 허용 각도 범위 (라디안)
      // 0.17 rad ≈ 10도 - 중력벡터에서 10도 이내의 평면만 찾음 (벽 제외)
      seg.setEpsAngle(0.17);  // ~10 degrees

      RCLCPP_DEBUG(this->get_logger(),
                   "RANSAC searching for plane perpendicular to gravity: [%.3f, %.3f, %.3f]",
                   floor_axis.x(), floor_axis.y(), floor_axis.z());
    } else {
      // IMU가 없으면 고정 축 사용
      Eigen::Vector3f fixed_axis(0.0, -1.0, 0.0);

      seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
      seg.setAxis(fixed_axis);
      seg.setEpsAngle(0.17);  // ~10 degrees

      RCLCPP_DEBUG(this->get_logger(),
                   "RANSAC searching for plane perpendicular to fixed axis: [0, -1, 0]");
    }

    seg.setInputCloud(cloud);
    seg.segment(*inliers, *coefficients);

    if (inliers->indices.empty()) {
      RCLCPP_WARN(this->get_logger(), "Could not find a planar model");
      return false;
    }

    // Extract plane normal
    Eigen::Vector3d plane_normal(coefficients->values[0],
                                   coefficients->values[1],
                                   coefficients->values[2]);
    plane_normal.normalize();

    // PRIMARY validation: Check against IMU gravity vector
    // IMU gravity vector를 사용해서 물리적으로 바닥인지 검증
    if (use_imu_for_validation_ && !imu_buffer_.empty()) {
      // Floor normal은 gravity 반대 방향 (위쪽)
      Eigen::Vector3d imu_floor_normal = -gravity_vector_;
      double imu_alignment = plane_normal.dot(imu_floor_normal);

      RCLCPP_INFO(this->get_logger(),
                   "Plane normal: [%.3f, %.3f, %.3f], IMU floor normal: [%.3f, %.3f, %.3f], alignment: %.3f (threshold: %.2f)",
                   plane_normal.x(), plane_normal.y(), plane_normal.z(),
                   imu_floor_normal.x(), imu_floor_normal.y(), imu_floor_normal.z(),
                   imu_alignment, floor_normal_alignment_threshold_);

      // 중력벡터와의 정렬이 threshold보다 작으면 거부
      if (imu_alignment < floor_normal_alignment_threshold_) {
        RCLCPP_WARN(this->get_logger(),
                    "✗ REJECTED: Plane does not align with gravity (alignment=%.2f < %.2f)",
                    imu_alignment, floor_normal_alignment_threshold_);
        return false;
      }

      RCLCPP_INFO(this->get_logger(), "✓ IMU validation passed: alignment=%.2f", imu_alignment);
    } else {
      // IMU가 없으면 고정 벡터로 fallback
      Eigen::Vector3d fixed_floor_normal(0.0, -1.0, 0.0);
      double alignment = plane_normal.dot(fixed_floor_normal);

      RCLCPP_INFO(this->get_logger(),
                   "Plane normal: [%.3f, %.3f, %.3f], fixed normal: [%.3f, %.3f, %.3f], alignment: %.3f (threshold: %.2f)",
                   plane_normal.x(), plane_normal.y(), plane_normal.z(),
                   fixed_floor_normal.x(), fixed_floor_normal.y(), fixed_floor_normal.z(),
                   alignment, floor_normal_alignment_threshold_);

      if (alignment < floor_normal_alignment_threshold_) {
        RCLCPP_WARN(this->get_logger(),
                    "✗ REJECTED: Plane not horizontal or wrong direction (alignment=%.2f < %.2f)",
                    alignment, floor_normal_alignment_threshold_);
        return false;
      }

      RCLCPP_WARN(this->get_logger(), "⚠ Using fixed reference vector (no IMU data available)");
    }

    // Additional validation: Check if plane is at reasonable height
    // Plane equation: ax + by + cz + d = 0
    double plane_height = -coefficients->values[3];

    RCLCPP_INFO(this->get_logger(),
                "Plane height: %.2fm (range: -0.5 to %.2f)",
                plane_height, max_height_threshold_);

    // Filter out planes that are too far (likely ceiling or noise)
    if (plane_height > max_height_threshold_ || plane_height < -0.5) {
      RCLCPP_WARN(this->get_logger(),
                  "✗ REJECTED: Unreasonable height (%.2fm outside range)",
                  plane_height);
      return false;
    }

    // Store plane coefficients directly (no smoothing)
    plane_coeffs << coefficients->values[0],
                    coefficients->values[1],
                    coefficients->values[2],
                    coefficients->values[3];

    RCLCPP_DEBUG(this->get_logger(),
                 "Floor plane found: [%.3f, %.3f, %.3f, %.3f], height: %.2fm",
                 plane_coeffs[0], plane_coeffs[1], plane_coeffs[2], plane_coeffs[3], plane_height);

    return true;
  }

  void removeFloorPlane(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud_in,
                        const Eigen::Vector4d& plane_coeffs,
                        pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud_out,
                        pcl::PointCloud<pcl::PointXYZRGB>::Ptr& floor_out)
  {
    // Plane equation: ax + by + cz + d = 0
    // Distance from point to plane: (ax + by + cz + d) / sqrt(a^2 + b^2 + c^2)
    // Since normal is normalized, denominator is 1

    double a = plane_coeffs[0];
    double b = plane_coeffs[1];
    double c = plane_coeffs[2];
    double d = plane_coeffs[3];

    for (const auto& point : cloud_in->points) {
      double distance = a * point.x + b * point.y + c * point.z + d;

      // Points above threshold: keep as non-floor
      // Points at or below threshold: classify as floor (including everything below)
      if (distance >= plane_distance_threshold_ && distance <= max_height_threshold_) {
        cloud_out->points.push_back(point);
      } else if (distance < plane_distance_threshold_) {
        floor_out->points.push_back(point);
      }
    }

    cloud_out->width = cloud_out->points.size();
    cloud_out->height = 1;
    cloud_out->is_dense = false;

    floor_out->width = floor_out->points.size();
    floor_out->height = 1;
    floor_out->is_dense = false;

    RCLCPP_DEBUG(this->get_logger(),
                 "Floor removal: %zu total -> %zu kept, %zu floor",
                 cloud_in->points.size(), cloud_out->points.size(), floor_out->points.size());
  }

  void publishCloud(rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr pub,
                    const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud,
                    const std_msgs::msg::Header& header)
  {
    sensor_msgs::msg::PointCloud2 msg;
    pcl::toROSMsg(*cloud, msg);
    msg.header = header;
    pub->publish(msg);
  }

  void publishGravityMarker(const std_msgs::msg::Header& header)
  {
    // Red arrow: gravity vector (pointing down)
    visualization_msgs::msg::Marker gravity_marker;
    gravity_marker.header = header;
    gravity_marker.ns = "gravity_vector";
    gravity_marker.id = 0;
    gravity_marker.type = visualization_msgs::msg::Marker::ARROW;
    gravity_marker.action = visualization_msgs::msg::Marker::ADD;

    geometry_msgs::msg::Point start, end;
    start.x = start.y = start.z = 0.0;
    double scale = 0.5;
    end.x = gravity_vector_.x() * scale;
    end.y = gravity_vector_.y() * scale;
    end.z = gravity_vector_.z() * scale;

    gravity_marker.points.push_back(start);
    gravity_marker.points.push_back(end);
    gravity_marker.scale.x = 0.02;
    gravity_marker.scale.y = 0.04;
    gravity_marker.color.r = 1.0;
    gravity_marker.color.a = 1.0;
    gravity_marker.lifetime = rclcpp::Duration::from_seconds(0.2);

    gravity_marker_pub_->publish(gravity_marker);

    // Green arrow: expected floor normal (pointing up, opposite of gravity)
    visualization_msgs::msg::Marker floor_marker;
    floor_marker.header = header;
    floor_marker.ns = "floor_normal";
    floor_marker.id = 1;
    floor_marker.type = visualization_msgs::msg::Marker::ARROW;
    floor_marker.action = visualization_msgs::msg::Marker::ADD;

    geometry_msgs::msg::Point floor_end;
    floor_end.x = -gravity_vector_.x() * scale;
    floor_end.y = -gravity_vector_.y() * scale;
    floor_end.z = -gravity_vector_.z() * scale;

    floor_marker.points.push_back(start);
    floor_marker.points.push_back(floor_end);
    floor_marker.scale.x = 0.02;
    floor_marker.scale.y = 0.04;
    floor_marker.color.g = 1.0;
    floor_marker.color.a = 1.0;
    floor_marker.lifetime = rclcpp::Duration::from_seconds(0.2);

    gravity_marker_pub_->publish(floor_marker);
  }

  // ROS subscribers and publishers
  rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr cloud_sub_;
  rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_sub_;
  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr cloud_pub_;
  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr floor_pub_;
  rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr gravity_marker_pub_;

  // Parameters
  std::string input_cloud_topic_;
  std::string input_imu_topic_;
  std::string output_cloud_topic_;
  std::string floor_cloud_topic_;
  std::string gravity_marker_topic_;
  double voxel_leaf_size_;
  double plane_distance_threshold_;
  int plane_max_iterations_;
  int imu_buffer_size_;
  bool use_imu_for_validation_;
  double max_height_threshold_;
  double floor_normal_alignment_threshold_;
  double plane_smoothing_alpha_;
  double min_distance_;
  double max_distance_;

  // IMU data buffer
  std::deque<sensor_msgs::msg::Imu::SharedPtr> imu_buffer_;

  // Gravity vector estimate
  Eigen::Vector3d gravity_vector_;

  // Previous valid floor plane (for temporal consistency)
  Eigen::Vector4d previous_plane_coeffs_;
  bool has_previous_plane_;
};

int main(int argc, char** argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<FloorRemoverNode>());
  rclcpp::shutdown();
  return 0;
}
